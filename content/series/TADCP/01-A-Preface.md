+++
draft = false
title = 'How to Think Like a Computer' 
series = ['The Art and Design of Computer Programs']
tags = ['tadcp']
+++

There is something special about light. Many societies and cultures have myths about it: From Prometheus and fire, to stories about the sun and the moon. So beloved is our most basic contrast: Light and Dark, that it appears even in our most complex devices. Computers run on binary, a number system based on 1 and 0. Also like fire, computers have changed the landscape of our entire world. This digital fire has allowed for breakthroughs in supply chains, science, engineering, physics, and space travel. With these machines help, we have broken the interstellar seal and proven to ourselved and all our blue, cosmic island home, that humanity is destined for greatness.

And yet, with our capacity for great development comes a risk of losing the very skills needed to be able to understand the very technology we build. Many developers are choosing to sacrifice their knowledge in the name of vibes, choosing the way of sloppy ease, rather than detailed, well-organized design. The result are increased bugs, security holes, downtime and outages in critical system, broken systems, and entire applications that simply no longer function.

The need to return to a more principled era is upon us, now more than ever. We do not call it engineering for no reason: To engineer is to design with stability and core principles in mind, not as an afterthought. As a result of this, I have been frequently thinking about [this old MIT course a lot](https://ocw.mit.edu/courses/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video_galleries/video-lectures/). The videos and technology are long outdated, but there is something charming about the methodology of the principles: Seeing programming as some wizardry, a form of magic. Something to be respected and harnessed correctly, not blasted everywhere like a protectionless Benjamin Franklin.

To that end, I have started this series as a way to return to these principles, to start from the beginning as it were, for people who may have always taken an interested in truly being a programmer or wanting to know how to program from the first principles, then I hope the resources I have can help you do that.

## Video Link

## Exercises

### 1- Write out the algorithm for one of these activities in precise steps:

- Making a cup of coffee/tea
- Tying your shoes
- Logging into a website


Are there any ambiguities that you nitpick through? Computer are not able to infer from what you say broadly. You must be specific and detailed. Computers do not care whether you missed a step. They will follow what you write, exactly. knowing what you want to say versus knowing how to say it are two different things.

### 2- Consider Pythagoras's Theorem: a^2 + b^2 = c^2.

Design a step-by-step procedure for resolving the theory, when a and c are both known. How would you take in an input and give an output?

### 3- Write an algorithm in normal language for:

- Finding a specific book on a bookshelf
- Deciding what to wear based on the weather
- Choosing which line to stand in at a grocery store

Like with exercise 1 and 2 above, is there a way in which you could write it such that you can detail exactly how to perform the task?

## Additional Resources for Learning:

1. Beej’s Guide to C Programming
2. Effective C: An Introduction to Professional C Programming
3. The C Programming Language
4. The OG book where “Hello, World!” was first introduced.
5. CodeVault
6. The C Programming Language Podcast



