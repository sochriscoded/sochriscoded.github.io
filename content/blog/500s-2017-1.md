+++
date = '2025-10-13'
draft = false
title = '500 Stars: An Advent of Code Journey'
+++

My favorite thing to tell people is that I like to run. Not like, a 5k or a few miles, I mean like half-marathons, 20k, or full marathons (don't check my time though, I am not setting the world on fire with speed.) I will never be a Eulid Kipchoge, that is for certain, but there is some fun validation that comes from attempting the challenge.

Likewise, I am no competative programmer and will never set the world on fire. I am by all accounts, an average programmer. But that doesn't stop me from attempting Advent of Code each and every year. There's something about the festive challenge that adds to the season. While my wife is snuggled by the hearth reading a book, the Christmas tree is twinkling, the Advent Wreath glowing, and my kid is fast asleep dreaming of Santa and his sleigh, I am busy trying to [fix his timestream](https://adventofcode.com/2018/day/1) or [stop the easter bunny from stealing his holiday](https://adventofcode.com/2024/day/8). 

The challenges range from trivial to mind-boggling complex, each one pushing the limits and boundaries of what a programmer might know. Naturally, I enjoy these sorts of challenges and problems, so I am on a quest to collect all 500+ stars like some Christmas-themed infinity gauntlet. Thankfully, I've done a few challenges already, but I will go over these as they come up, to explore how I wrote them at the time, and how I would rewrite those solutions now.

## How I'm Tackling it:

There's a cool [graph that shows average time to solve a particular AOC challenge](https://aoc.xhyrom.dev/). While these aren't implictly accurate to gauge level of difficulty (just look at the gajillion "easy" leetcode questions and how many people struggle with them), I will use them as a good starting point to determine which ones to do first, and which ones to save for later.

Second, most of these problems are algorithmic in nature, and thus have a rather elegant mathematical solution. I'll try to explore these problem in that light, but I do reconize the limitation of programming languages as a whole. Likewise, I'll also be solving the challenges in Go. I'm picking Go for several reasons: 1. I like it. Simple as. 2. I like the bufio package 3. I like it lol.

If you don't like Go, I'm still exploring the problems from a mathematical perspective, thus you can implement an algorithm in any language you choose. I'm also slowly building several learning sections using Go as my chosen language, and others talking about math from an "fully developed frontal lobe perspective" here on this site, so keep an eyeball out for those.


Otherwise, Happy Soon-To-Be Advent, Happy Soon-To-Be Advent of Code, and Happy Soon-To-Be Holidays!


